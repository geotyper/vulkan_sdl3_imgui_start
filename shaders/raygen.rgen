#version 460 core
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : require

#include "../src/shared_with_shaders.h"

layout(set = SWS_SCENE_AS_SET, binding = SWS_SCENE_AS_BINDING)
uniform accelerationStructureEXT topLevelAS;
layout(set = SWS_RESULT_IMAGE_SET, binding = SWS_RESULT_IMAGE_BINDING, rgba8) uniform image2D accumImage;
layout(set = SWS_CAMERA_SET, binding = SWS_CAMERA_BINDING) uniform CameraUBO {
    mat4 invView;
    mat4 invProj;
} cam;

layout(location = SWS_LOC_PRIMARY_RAY) rayPayloadEXT RadiancePayload prd;

void main() {
    // 1. Получаем координаты пикселя в диапазоне [0, 1]
    vec2 uv = (vec2(gl_LaunchIDEXT.xy) + 0.5) / vec2(gl_LaunchSizeEXT.xy);
    // и переводим их в Normalised Device Coordinates [-1, 1]
    vec2 ndc = uv * 2.0 - 1.0;

    // 2. Вычисляем начало и направление луча в мировых координатах
    
    // Начало луча — это позиция камеры. Её можно извлечь из инвертированной матрицы вида.
    vec3 origin = cam.invView[3].xyz;

    // Направление луча вычисляется путем обратного проецирования
    vec4 target = cam.invProj * vec4(ndc.xy, 1.0, 1.0);
    vec3 dir_view_space = normalize(target.xyz / target.w);
    vec3 dir_world_space = normalize((cam.invView * vec4(dir_view_space, 0.0)).xyz);

    // 3. Сбрасываем payload и запускаем основной луч
    prd.color = vec3(0.0); // Обнуляем цвет перед трассировкой
    prd.depth = 0;
    
    traceRayEXT(
        topLevelAS,
        gl_RayFlagsOpaqueEXT,
        0xFF,
        0, 0,
        SWS_PRIMARY_MISS_IDX,  // Используем основной miss-шейдер для фона
        origin, 0.001,
        dir_world_space, 1e30,
        SWS_LOC_PRIMARY_RAY
    );

    // 4. Записываем результат в итоговое изображение
    imageStore(accumImage, ivec2(gl_LaunchIDEXT.xy), vec4(prd.color, 1.0));
}
